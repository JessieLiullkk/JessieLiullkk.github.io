---
title: 同步/异步
tags: [ES6]
renderNumberedHeading: true
grammar_cjkRuby: true
---

#### 1. 同步和异步
##### js是单线程的，同时只能有一个任务在主线程允许，而像api请求这种，需要等到请求完成拿到数据后才能继续向下执行的任务成为`异步任务`，在请求未完成前，将任务放到`任务队列`中，等到请求完成，再通过回调等方式通知主线程。

#### 2. promise
- pending
- fulfilled
- rejected

##### 2-1. promise 对象是一个构造函数
```markdown
const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */) {
    resolve(value);
  } else {
    reject(error);
  }
});
```
##### 2-2. Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。
```markdown
promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
```
##### 2-3. Promise中resolve(promise实例)
```markdown
const p1 = new Promise(function (resolve, reject) {
  setTimeout(() => reject(new Error('fail')), 3000)
})

const p2 = new Promise(function (resolve, reject) {
  setTimeout(() => resolve(p1), 1000)
})

p2
  .then(result => console.log(result))
  .catch(error => console.log(error))
// Error: fail
`上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。
由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。
所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。`
```
##### 2-4. 调用resolve或reject并不会终结 Promise 的参数函数的执行
```markdown
new Promise((resolve, reject) => {
  resolve(1);
  console.log(2);
}).then(r => {
  console.log(r);
});
// 2
// 1

new Promise((resolve, reject) => {
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
})
```