---
title: Generator
tags: ES6, 异步编程
renderNumberedHeading: true
grammar_cjkRuby: true
---

#### Generator定义
##### 一是，function关键字与函数名之间有一个星号；
##### 二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。

#### 遍历器对象的next方法的运行逻辑如下。

（1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。

（2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。

（3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。

（4）如果该函数没有return语句，则返回的对象的value属性值为undefined。

```markdown
function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}

var a = foo(5); `指针停在第一个yield`
a.next() // Object{value:6, done:false}  `value = 第一个yield 后面表达式的值 = x+1 = 5`
a.next() // Object{value:NaN, done:false} `next()没有传值，上一个yield (x+1)的值为NaN, 所以y值为NaN, y/3为NaN`
a.next() // Object{value:NaN, done:true} `next()没有传值，上一个yield (y/3)的值为NaN, z为NaN， 5+NaN+NaN`

var b = foo(5);
b.next() // { value:6, done:false } `第一个next传值是无效的, next是给上一个yield表达式传值`
b.next(12) // { value:8, done:false } => `yield(x + 1) = 12; y = 2*12 = 24; yield value = > y/3 = 8;`
b.next(13) // { value:42, done:true } =>`yield(y / 3) = 13; z = 13; yield value => x+y+z = 5+24+13 = 42`

####  Object{value:6, done:false} value => yield后表达式的值，无则返回undefined; done => generator执行完返回done
```
### Interator
四种数据集合 Array Object Set Map

Interator 遍历器： 依次处理该数据的所有成员（指针对象）
一是为各种数据结构，提供一个统一的、简便的访问接口；
二是使得数据结构的成员能够按某种次序排列；
三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。

具有Symbol.iterator属性的对象都是可遍历的，调用这个属性，就会返回一个遍历器对象
```markdown
let arr = ['a', 'b', 'c'];
let iter = arr[Symbol.iterator]();

iter.next() // { value: 'a', done: false }
iter.next() // { value: 'b', done: false }
iter.next() // { value: 'c', done: false }
iter.next() // { value: undefined, done: true }
```
原生具备 Iterator 接口的数据结构如下：Array/Map/SetString/TypedArray/函数的 arguments 对象/NodeList 对象，

### next()/throw()/return()的共同之处
##### next()是将yield表达式替换成一个值。
```markdown
const g = function* (x, y) {
  let result = yield x + y;
  return result;
};

const gen = g(1, 2);
gen.next(); // Object {value: 3, done: false}

gen.next(1); // Object {value: 1, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = 1;
```
##### throw()是将yield表达式替换成一个throw语句。
```markdown
gen.throw(new Error('出错了')); // Uncaught Error: 出错了
// 相当于将 let result = yield x + y
// 替换成 let result = throw(new Error('出错了'));
```
##### return()是将yield表达式替换成一个return语句。
```markdown
gen.return(2); // Object {value: 2, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = return 2;
```